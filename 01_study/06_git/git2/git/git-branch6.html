파일을 수정하고 다시 커밋을 해보자.

    $ vim test.rb
    $ git commit -a -m 'made other changes'

프로젝트 히스토리는 분리돼 진행한다(갈라지는 브랜치).
우리는 브랜치를 하나 만들어 그 브랜치에서 일을 좀 하고, 다시 원래 브랜치로 되돌아와서 다른 일을 했다.
두 작업 내용은 서로 독립적으로 각 브랜치에 존재한다.
커밋 사이를 자유롭게 이동하다가 때가 되면 두 브랜치를 Merge 한다.
간단히 branch, checkout, commit 명령을 써서 말이다.

<img src="img/git-branch9.jpg" alt="">

git log 명령으로 쉽게 확인할 수 있다.
현재 브랜치가 가리키고 있는 히스토리가 무엇이고 어떻게 갈라져 나왔는지 보여준다.
git log --oneline --decorate --graph --all 이라고 실행하면 히스토리를 출력한다.

    $ git log --oneline --decorate --graph --all
    * c2b9e (HEAD, master) made other changes
    | * 87ab2 (testing) made a change
    |/
    * f30ab add feature #32 - ability to add new formats to the
    * 34ac2 fixed bug #1328 - stack overflow under certain conditions
    * 98ca9 initial commit of my project


실제로 Git의 브랜치는 어떤 한 커밋을 가리키는 40글자의 SHA-1 체크섬 파일에 불과하기 때문에 만들기도 쉽고 지우기도 쉽다.
새로 브랜치를 하나 만드는 것은 41바이트 크기의 파일을(40자와 줄 바꿈 문자) 하나 만드는 것에 불과하다.

브랜치가 필요할 때 프로젝트를 통째로 복사해야 하는 다른 버전 관리 도구와 Git의 차이는 극명하다.
통째로 복사하는 작업은 프로젝트 크기에 따라 다르겠지만 수십 초에서 수십 분까지 걸린다.
그에 비해 Git은 순식간이다.
게다가 커밋을 할 때마다 이전 커밋의 정보를 저장하기 때문에 Merge 할 때 어디서부터(Merge Base) 합쳐야 하는지 안다.
이런 특징은 개발자들이 수시로 브랜치를 만들어 사용하게 한다.

이제 왜 그렇게 브랜치를 수시로 만들고 사용해야 하는지 알아보자.

